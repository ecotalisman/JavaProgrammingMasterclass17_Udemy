package Section_7_OOP_Part_1_Inheritance.CodingExercise_30_to_37.Ex_31_Person;

public class Person {

    private String firstName;
    private String lastName;
    private int age;

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age < 0 || age > 100) {
           this.age = 0;
        } else {
            this.age = age;
        }
    }

    public boolean isTeen() {
        if (age > 12 && age < 20) {
            return true;
        } else {
            return false;
        }
    }

    public String getFullName() {
        int fullName = Math.max((firstName.isEmpty() ? 0 : 1) + (lastName.isEmpty() ? 0 : 2), 0);
        if (fullName == 0) {
            return "";
        } else if (fullName == 1) {
            return firstName;
        } else if (fullName == 2) {
            return lastName;
        } else {
            return firstName + " " + lastName;
        }
    }

//    Second Version:

    /*
    Second Version код не ефективний, оскільки містить дублювання коду. Якщо змінити порядок перевірки умов у цьому коді,
    то він буде працювати не правильно. Наприклад, якщо переставити рядки коду так, щоб першим було перевірено lastName, то
    цей код поверне неправильний результат, якщо ім'я буде порожнім, а прізвище - ні.

    Код, Math.max більш ефективний, оскільки використовує математичну функцію Math.max(), що дозволяє знайти максимальне
    значення між двома виразами. Він також коротший за попередній код, оскільки не містить дублювання умов.
    */
    
//    public String getFullName() {
//        if (firstName.isEmpty() && lastName.isEmpty()) {
//            return "";
//        } else if (lastName.isEmpty()) {
//            return firstName;
//        } else if (firstName.isEmpty()) {
//            return lastName;
//        } else{
//            return firstName + " " + lastName;
//        }
//    }

}

/*

int fullName = Math.max((firstName.isEmpty() ? 0 : 1) + (lastName.isEmpty() ? 0 : 2), 0);
Функція Math.max() приймає два аргументи, та повертає більший з них. Якщо один із аргументів не є числом, то повернеться значення NaN (Not a Number).

У коді, функція Math.max() використовується для того, щоб обчислити змінну nameState. Ця змінна відображає стан імені: якщо firstName пустий,
і lastName не пустий, то nameState дорівнює 2, якщо lastName пустий і firstName не пустий, то nameState дорівнює 1. Якщо обидва поля порожні, то nameState
дорівнює 0, щоб повернути порожній рядок.

У твоєму випадку, Math.max() використовується разом з оператором +, щоб обчислити суму двох значень. Першим аргументом є результат тернарного оператора
(firstName.isEmpty() ? 0 : 1), який поверне 0, якщо рядок firstName порожній, або 1, якщо він не порожній. Другим аргументом є результат тернарного
оператора (lastName.isEmpty() ? 0 : 2), який поверне 0, якщо рядок lastName порожній, або 2, якщо він не порожній. Результат цієї операції буде дорівнювати
одному з трьох значень: 0, 1 або 2.

Пізніше, отримане значення використовується як перший аргумент для Math.max(). Якщо результат суми двох тернарних операторів є меншим за 0 (що не можливо,
тому що обидва операнди - це додатні числа), то повернеться 0. Інакше повернеться значення, яке дорівнює більшому з двох чисел - 1 або 2. Таким чином,
результат функції Math.max() буде дорівнювати 0, 1 або 2, в залежності від того, чи є firstName або lastName порожніми.


******************************THIRD VERSION********************************************************************************************************************

public String getFullName() {
    int nameState = (firstName.isEmpty() ? 0 : 1) | (lastName.isEmpty() ? 0 : 2);
    return switch (nameState) {
        case 0 -> "";
        case 1 -> firstName;
        case 2 -> lastName;
        default -> firstName + " " + lastName;
    };
}

У цьому варіанті ми використовуємо операцію | для об'єднання двох значень (0 або 1) в одне. Згодом ми використовуємо switch для перевірки,
які з двох значень дорівнюють 1, 2 або обидва. В залежності від того, які значення дорівнюють 1 або 2, ми повертаємо відповідний рядок.
Якщо обидва значення дорівнюють 0, повертаємо порожній рядок.

Оператор | в Java є бітовим оператором "OR". Його можна використовувати для виконання логічної операції OR між двійковими значеннями двох операндів.
В коді, який наведено, використовується оператор | для обчислення значення виразу, який передається в switch оператор. Цей вираз складається з двох
окремих значень, які використовуються як бітові флаги, щоб вказати, які поля об'єкту Person (firstName і lastName) є порожніми (тобто, чи дорівнює
їхній вміст порожньому рядку).

Тому щоб додати значення флага для firstName, тобто 1, ми перевіряємо, чи є firstName порожнім рядком за допомогою firstName.isEmpty(),
якщо так, то повертається 0. Якщо firstName містить значення, то повертається 1.

Так само, щоб додати значення флага для lastName, ми перевіряємо, чи є lastName порожнім рядком за допомогою lastName.isEmpty(), якщо так,
то повертається 0. Якщо lastName містить значення, то повертається 2.

Отже, при обчисленні виразу firstName.isEmpty() ? 0 : 1 | lastName.isEmpty() ? 0 : 2 ми виконуємо логічну операцію OR між двома бітовими
значеннями - одне отримане з firstName іншого отриманого з lastName. Результатом цієї операції є число, яке відповідає комбінації двох бітових флагів.

Наприклад, якщо firstName має значення, а lastName - ні, то firstName.isEmpty() буде false, а lastName.isEmpty() буде true. Тому, значення флага
для firstName буде 1, а для lastName буде 0. Результатом логічної операції OR між 1 і 0 буде 1,
тому вираз firstName.isEmpty() ? 0 : 1 | lastName.isEmpty() ? 0 : 2 поверне 1.

У разі, якщо як firstName, так і lastName мають значення, тоді вираз firstName.isEmpty() буде false, а lastName.isEmpty() теж буде false. Результатом
логічної операції OR між 1 і 2 буде 3, тому вираз firstName.isEmpty() ? 0 : 1 | lastName.isEmpty() ? 0 : 2 поверне 3.

Таким чином, використання оператора | дозволяє об'єднати результати двох тернарних операторів в одне число, яке потім може бути використане у switch-блоку
для визначення потрібної гілки коду.



Логічна операція OR використовується для об'єднання двох булевих значень. Результатом операції буде true, якщо хоча б один з операндів має значення true.
Якщо ж обидва операнди мають значення false, результатом буде false.

Оператор | виконує логічну операцію OR між двома числами у двійковій системі числення. Якщо хоча б один біт має значення 1, то відповідний біт у результаті
буде мати значення 1.

Розглянемо таблицю для операції OR між двома числами, де кожен рядок представляє собою двійкове значення кожного числа та результат операції:

Операнд 1	Операнд 2	Результат
    0	        0	        0
    0	        1	        1
    1	        0	        1
    1	        1	        1

Тепер розглянемо конкретний випадок, коли firstName.isEmpty() повертає false, а lastName.isEmpty() повертає true. Це значить, що firstName
не є порожнім рядком, а lastName є порожнім рядком.

За допомогою тернарного оператора ? : обчислюємо значення флагів для firstName та lastName. Оскільки firstName не є порожнім рядком, то флаг
для нього буде 1. Оскільки lastName є порожнім рядком, то флаг для нього буде 0.

Далі виконується операція 1 | 0, яка дорівнює 1. Отже, вираз firstName.isEmpty() ? 0 : 1 | lastName.isEmpty() ? 0 : 2 поверне 1.

У загальному випадку, якщо обидва операнди є порожніми рядками, то флаги будуть обидва 0, операція 0 | 0 поверне 0, і відповідь на вираз буде 0.
Якщо тільки firstName є непорожнім рядком, то флаг для нього буде 1, а для lastName - 2. Операція 1 | 2 поверне 3.


1 | 2 не означає 1 + 2. У Java символ | використовується для побітової логічної операції "OR".

При виконанні побітового "OR" двох чисел, результатом буде число, яке має встановлені біти, які встановлені в одному з двох операндів.
У випадку 1 | 2, це означає, що обидва операнди будуть перетворені до двійкової форми: 0001 (для числа 1) та 0010 (для числа 2). При
побітовому "OR" цих чисел, отримаємо результат 0011 (для числа 3 в десятковому форматі), оскільки біт зі значенням 1 присутній в другому операнді.

Таким чином, в випадку 1 | 2 результатом буде число 3, а не сума 1 і 2.



Всі випадки побітових операцій в двійковій формі:

| (OR):
  0b0 | 0b0 = 0b0
  0b0 | 0b1 = 0b1
  0b1 | 0b0 = 0b1
  0b1 | 0b1 = 0b1


& (AND):
  0b0 & 0b0 = 0b0
  0b0 & 0b1 = 0b0
  0b1 & 0b0 = 0b0
  0b1 & 0b1 = 0b1

^ (XOR):
  0b0 ^ 0b0 = 0b0
  0b0 ^ 0b1 = 0b1
  0b1 ^ 0b0 = 0b1
  0b1 ^ 0b1 = 0b0

~ (NOT):
  ~0b0 = 0b1
  ~0b1 = 0b0


<< (left shift):
  0b0001 << 1 = 0b0010
  0b0010 << 1 = 0b0100
  0b0100 << 1 = 0b1000


(right shift):
  0b1000 >> 1 = 0b0100
  0b0100 >> 1 = 0b0010
  0b0010 >> 1 = 0b0001

Звичайно, це всього лише декілька прикладів, але вони показують, як працюють різні побітові операції в двійковій формі.

Префікс 0b вказує на те, що наступні символи у літералі числа представляють двійкове число. Тобто, 0b0 представляє число 0 в двійковій формі.

Цей префікс можна використовувати для чисел в десятковій, шістнадцятковій, вісімковій та інших системах числення. Наприклад, для
шістнадцяткових чисел використовується префікс 0x, для вісімкових - 0, а для десяткових - не використовується жодного префікса.

У загальному випадку, префікс b сам по собі не має жодного особливого значення в Java.



Для розуміння виразу int nameState = (firstName.isEmpty() ? 0 : 1) | (lastName.isEmpty() ? 0 : 2) в двійковій формі, потрібно розбити цей вираз на складові:

1) firstName.isEmpty() ? 0 : 1
Цей вираз поверне 0, якщо firstName є порожнім рядком, або 1, якщо firstName не є порожнім рядком. У двійковій формі це буде:

- Якщо firstName є порожнім рядком: 0b0
- Якщо firstName не є порожнім рядком: 0b1

2) lastName.isEmpty() ? 0 : 2
Цей вираз поверне 0, якщо lastName є порожнім рядком, або 2, якщо lastName не є порожнім рядком. У двійковій формі це буде:

- Якщо lastName є порожнім рядком: 0b0
- Якщо lastName не є порожнім рядком: 0b10

3) (firstName.isEmpty() ? 0 : 1) | (lastName.isEmpty() ? 0 : 2)
Цей вираз об'єднує результати попередніх двох виразів за допомогою операції побітового OR. У двійковій формі це буде:

- Якщо обидва рядки є порожніми: 0b0 | 0b0 = 0b0
- Якщо firstName є порожнім рядком, а lastName не є порожнім рядком: 0b0 | 0b10 = 0b10
- Якщо firstName не є порожнім рядком, а lastName є порожнім рядком: 0b1 | 0b0 = 0b1
- Якщо обидва рядки не є порожніми: 0b1 | 0b10 = 0b11

Отже, результатом виразу int nameState = (firstName.isEmpty() ? 0 : 1) | (lastName.isEmpty() ? 0 : 2) буде:

0, якщо обидва рядки є порожніми
2, якщо firstName є порожнім рядком, а lastName не є порожнім рядком
1, якщо firstName не є порожнім рядком, а lastName є порожнім рядком
3, якщо обидва рядки не є порожніми.

Вираз (firstName.isEmpty() ? 0 : 1) | (lastName.isEmpty() ? 0 : 2) виконує побітову операцію "OR" між двома числами.
Для цього обидва операнди перетворюються в двійкову форму. Якщо firstName порожній рядок, то перше число буде 0, інакше - 1.
Якщо lastName порожній рядок, то друге число буде 0, інакше - 2. Таким чином, якщо обидва рядки порожні, то обидва числа будуть 0
в двійковій формі: 0000. Якщо лише firstName не порожній, то перше число буде 1: 0001. Якщо лише lastName не порожній, то друге
число буде 2: 0010. Якщо обидва рядки не порожні, то обидва числа будуть непорожніми: 0001 та 0010. Далі, виконується побітова
операція "OR" між цими числами, що дозволяє визначити стан nameState для поточного об'єкта.

Побітова операція OR (або "бітове додавання") - це бінарна операція, яка виконується на двох бітах і повертає 1, якщо хоча б один з
бітів є 1. Інакше, якщо обидва біти є 0, повертається 0.

Наприклад, якщо ми маємо двійкові числа 1101 та 1010 і застосовуємо до них побітову операцію OR, то отримаємо результат 1111, оскільки
на кожній позиції один з бітів є 1.

У нашому випадку, коли ми використовуємо побітову операцію OR для чисел 1 та 2, відбувається такий же процес, але замість окремих бітів
використовуються значення цілих чисел. У двійковій системі числення, число 1 має значення 0001, а число 2 - значення 0010. При застосуванні
побітової операції OR до цих чисел, результат буде 0011, оскільки на другій та третій позиції (відправно від правого кінця) один з бітів є 1.
Таким чином, отримуємо число 3 в десятковому вигляді, що відповідає бінарному числу 0011.


Основні бітові операції:

| (OR) - бітове додавання, додає 1 до відповідного біту, якщо хоча б один з операндів дорівнює 1;
& (AND) - бітове множення, повертає 1 відповідний біт, якщо обидва операнди дорівнюють 1;
^ (XOR) - бітова операція "виключне або", повертає 1 відповідний біт, якщо тільки один з операндів дорівнює 1;
~ (NOT) - бітова операція "НЕ", повертає зворотній результат до відповідного біту;
<< (left shift) - зсув бітів вліво на вказану кількість позицій;
(right shift) - зсув бітів вправо на вказану кількість позицій.


| (OR): це бітова операція, яка виконується над двійковими представленнями чисел і повертає результат, у якому біти відповідних позицій обох
чисел встановлені в 1, якщо вони принаймні в одному з них були 1. Наприклад, якщо ми застосуємо бітову операцію OR до двійкових чисел 0101
та 1100, то ми отримаємо 1101, що в десятковій системі складає 13.

& (AND): це бітова операція, яка виконується над двійковими представленнями чисел і повертає результат, у якому біти відповідних позицій обох
чисел встановлені в 1, тільки якщо вони були 1 в обох числах. Наприклад, якщо ми застосуємо бітову операцію AND до двійкових чисел 0101 та 1100,
то ми отримаємо 0100, що в десятковій системі складає 4.

^ (XOR): це бітова операція, яка виконується над двійковими представленнями чисел і повертає результат, у якому біти відповідних позицій обох
чисел встановлені в 1, тільки якщо вони були 1 в одному з чисел, але не в обох. Наприклад, якщо ми застосуємо бітову операцію XOR до двійкових
чисел 0101 та 1100, то ми отримаємо 1001, що в десятковій системі складає 9.

~ (NOT): це бітова операція, яка виконується над двійковим представленням числа і повертає результат, у якому всі біти інвертовані (тобто замінені
на протилежні). Наприклад, якщо ми застосуємо бітову операцію NOT до двійкового числа 0101, то ми отримаємо 1010. Це число у десятковій системі
складає -6 лише тоді, коли ми вважаємо його знаковим додатком до двійкового числа, що відповідає використанню знакового біту (найстаршого біту)
для позначення знака числа. Якщо ми не використовуємо знаковий біт, то число 1010 в двійковій системі відповідає десятковому числу 10.

<< (left shift): це бітова операція, яка зміщує всі біти числа вліво на задану кількість позицій, доповнюючи порожні місця нулями. Наприклад,
якщо ми застосуємо бітову операцію left shift до двійкового числа 0001 на 2 позиції, то ми отримаємо 0100.

>> (right shift): це бітова операція, яка зміщує всі біти числа вправо на задану кількість позицій, викидаючи старший біт і доповнюючи порожні
місця нулями або знаковим бітом. Якщо ми застосуємо бітову операцію right shift до двійкового числа 1010 на 2 позиції, то ми отримаємо 0010.
Якщо ми використовуємо знаковий біт, то right shift може змінювати знак числа. Наприклад, якщо ми застосуємо бітову операцію right shift до
двійкового числа 1101 на 1 позицію, то ми отримаємо 1110, що в десятковій системі складає -2, якщо ми вважаємо його знаковим додатком до
двійкового числа.


*/