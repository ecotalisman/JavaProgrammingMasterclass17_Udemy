package Section_6_Control_Flow.CodingExercise_13_to_29.Ex_26_LargestPrime;

public class LargestPrime {

    public static int getLargestPrime(int number) {

        if (number <= 1) {
            return -1;
        }

        int max = 2;
        while (max <= number) {

            if (number % max == 0) {
                number /= max;
            } else {
                max++;
            }
        }
        return max;
    }
}

/*      Аналіз ChatGPT мого коду

        У цьому коді є декілька помилок:
        1. Замість перевірки, чи є даний множник простим, код перевіряє, чи число ділиться на 5, що є неправильним.
        2. Змінна "count" повинна бути ініціалізована як 1, а не max.
        3. Під час перевірки, чи є число дільником, потрібно перевірити лише прості числа, а не всі числа від 1 до максимального.
        Ось виправлений код, який повинен працювати правильно:

        if (number <= 1) {
            return -1;
        }

        int max = 1;
        int count = 1;

        while (max * count != number) {

            if (number % max == 0) {
               count = max;
            }
            max++;
        }

        if (number % 5 == 0){
            max = count;
        }
        return max;
*/

//***********************************************************************************
//             Solution in Q&A Udemy Forum:
//
//        for (int i = number / 2; i > 1 ; i--) {
//            if (number % i == 0){
//                number = i;
//            }
//        }
//        return number;
//
//    Цей код може працювати швидше за попередній, оскільки використовує один цикл замість двох. Але, на жаль, це не дає правильного результату.
//    Основна проблема цього коду в тому, що він не перевіряє, чи є знайдені числа простими. Наприклад, якщо число 10 використовується як вхідне
//    значення, цей код поверне 5, хоча найбільший простий множник числа 10 - це 5 * 2 = 10.
//    Також, при поділі number на найдішовший його множник, він може стати меншим за поточне max, але max не буде оновлено, тому повернеться неправильний результат.
//    Отже, щоб правильно визначити найбільший простий множник числа, потрібно використовувати більш складний алгоритм, який перевірятиме кожне число від 2 до
//    кореня з числа, чи воно є простим множником числа.
//***********************************************************************************